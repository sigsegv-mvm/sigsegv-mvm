#include "mod.h"
#include "stub/entities.h"
#include "stub/tfplayer.h"
#include "stub/gamerules.h"
#include "stub/usermessages_sv.h"
#include "util/misc.h"
#include "util/iterate.h"


namespace Mod::Debug::Revive_Exploit
{
	void PrintToChatAll(const char *str)
	{
		int msg_type = usermessages->LookupUserMessage("SayText2");
		if (msg_type == -1) return;
		
		CReliableBroadcastRecipientFilter filter;
		
		bf_write *msg = engine->UserMessageBegin(&filter, msg_type);
		if (msg == nullptr) return;
		
		msg->WriteByte(0x00);
		msg->WriteByte(0x00);
		msg->WriteString(str);
		
		engine->MessageEnd();
	}
	
	
	bool obs_monitor = false;
	
	
	DETOUR_DECL_MEMBER(bool, CTFPlayer_ClientCommand, const CCommand& args)
	{
		if (FStrEq(args[0], "reviveinfo")) {
			CTFReviveMarker *reanimator = nullptr;
			ForEachEntityByRTTI<CTFReviveMarker>([&](CTFReviveMarker *marker){
				reanimator = marker;
			});
			
			if (reanimator != nullptr) {
				CTFPlayer *owner = ToTFPlayer(reanimator->m_hOwner);
				if (owner != nullptr) {
					float curtime = gpGlobals->curtime;
					
					if (FStrEq(args[1], "m_flDeathTime")) {
						float m_flDeathTime = owner->GetDeathTime();
						float delta = curtime - m_flDeathTime;
						PrintToChatAll(CFmtStr("\x07" "ffb200" "[Revive]" "\x01" " curtime: %.1f m_flDeathTime: %.1f delta: %.1f\n", curtime, m_flDeathTime, delta));
					} else if (FStrEq(args[1], "GetNextRespawnWave")) {
						float flNextRespawnWave = TFGameRules()->GetNextRespawnWave(owner->GetTeamNumber(), owner);
						float delta = flNextRespawnWave - curtime;
						PrintToChatAll(CFmtStr("\x07" "ffb200" "[Revive]" "\x01" " curtime: %.1f GNRW: %.1f delta: %.1f\n", curtime, flNextRespawnWave, delta));
					} else if (FStrEq(args[1], "GetMinTimeWhenPlayerMaySpawn")) {
						float flMinTimeWhenPlayerMaySpawn = TFGameRules()->GetMinTimeWhenPlayerMaySpawn(owner);
						float delta = flMinTimeWhenPlayerMaySpawn - curtime;
						PrintToChatAll(CFmtStr("\x07" "ffb200" "[Revive]" "\x01" " curtime: %.1f GMTWPMS: %.1f delta: %.1f\n", curtime, flMinTimeWhenPlayerMaySpawn, delta));
					} else {
						PrintToChatAll(CFmtStr("\x07" "ffb200" "[Revive]" "\x01" " no valid argument: '%s'\n", args[1]));
					}
				} else {
					PrintToChatAll("\x07" "ffb200" "[Revive]" "\x01" " owner is nullptr?!\n");
				}
			} else {
				PrintToChatAll("\x07" "ffb200" "[Revive]" "\x01" " no reanimators found\n");
			}
			
			return true;
		}
		
		if (FStrEq(args[0], "obs_on")) {
			obs_monitor = true;
			return true;
		}
		if (FStrEq(args[0], "obs_off")) {
			obs_monitor = false;
			return true;
		}
		
		return DETOUR_MEMBER_CALL(CTFPlayer_ClientCommand)(args);
	}
	
	
	class CMod : public IMod, public IFrameUpdateListener
	{
	public:
		CMod() : IMod("Debug:Revive_Exploit")
		{
			MOD_ADD_DETOUR_MEMBER(CTFPlayer_ClientCommand, "CTFPlayer::ClientCommand");
		}
		
		virtual bool ShouldReceiveFrameEvents() const override { return this->IsEnabled(); }
		
		virtual void FrameUpdatePostEntityThink() override
		{
			static CountdownTimer ct;
			if (ct.IsElapsed()) {
				ct.Start(0.100f);
				
				if (obs_monitor) {
					CTFReviveMarker *reanimator = nullptr;
					ForEachEntityByRTTI<CTFReviveMarker>([&](CTFReviveMarker *marker){
						reanimator = marker;
					});
					
					if (reanimator != nullptr) {
						CTFPlayer *owner = ToTFPlayer(reanimator->m_hOwner);
						if (owner != nullptr) {
							bool is_observer = owner->IsObserver();
							unsigned int obs_mode = owner->GetObserverMode();
							bool can_buyback = (is_observer && ((unsigned int)(obs_mode - 1U) > 1U));
							
							const char *obs_str = "???";
							switch (obs_mode) {
							case OBS_MODE_NONE:      obs_str = "NONE";      break;
							case OBS_MODE_DEATHCAM:  obs_str = "DEATHCAM";  break;
							case OBS_MODE_FREEZECAM: obs_str = "FREEZECAM"; break;
							case OBS_MODE_FIXED:     obs_str = "FIXED";     break;
							case OBS_MODE_IN_EYE:    obs_str = "IN_EYE";    break;
							case OBS_MODE_CHASE:     obs_str = "CHASE";     break;
							case OBS_MODE_POI:       obs_str = "POI";       break;
							case OBS_MODE_ROAMING:   obs_str = "ROAMING";   break;
							}
							
							PrintToChatAll(CFmtStr("\x07" "ffb200" "[Revive]" "\x01" " can_buyback: %-5s  is_observer: %-5s  obs_mode: %d %s\n", (can_buyback ? "true" : "false"), (is_observer ? "true" : "false"), obs_mode, obs_str));
						}
					}
				}
			}
		}
	};
	CMod s_Mod;
	
	
	ConVar cvar_enable("sig_debug_revive_exploit", "0", FCVAR_NOTIFY,
		"Debug: investigate a MvM buyback-during-revive exploit",
		[](IConVar *pConVar, const char *pOldValue, float flOldValue){
			s_Mod.Toggle(static_cast<ConVar *>(pConVar)->GetBool());
		});
}
